function [logpseq, normalpha, normbeta, scaling] = dwHMMdecode(seq,A,B)

%% Compute probabiliy of sequence given a HMM model params: A,B

% Forward - backward algorithm for computing log likelihood of seq given A
% and B model parameters for HMM:
% INPUTS
% seq: vector of emissions 
% A: [numState x numState] transition probabilities 
% B: [numState x numEmission] emission probabilities
%
% OUTPUTS
% logpseq: double log likelihood of sequence generated by A,B
%% OUTPUTS for dwHMMtrain:
% normalpha: forward algorithm alpha(state,t) = sum_i(alpha_t(i) A(i,j) ) B(state,seq(t+1)
% normbeta: backward algorithm 
% alpha: 

% initialize 

numState = size(A,1);
numEm = size(B,2); 

pi = zeros(1,numState);
pi(1) = 1;


%% Probability computation using forward procedure

% 1 Initialization:
% a_t = a(:,t) each column of 'a' corresponds to a time. 
% each row is a state
scaling = zeros(1,length(seq));
normalpha = zeros(numState,length(seq));

scaling(1) = 1; % initialize alpha

normalpha(1) = 1;

% 2 Induction
for t = 2:length(seq)

    for state = 1:numState
        %sumalphaA = sum(repmat(exp(logalpha(:,t-1)),[1,numState]).*A,2);
        %alpha(:,t) = sumalphaA.*B(:,seq(t));
        % scaled version:
        sumalphaA = sum(normalpha(:,t-1) .* A(:,state));
        normalpha(state,t) = sumalphaA * B(state,seq(t));
    end
    
    scaling(t) = sum(normalpha(:,t));
    % normalize alpha so that at each time sum(normalpha(:,t)) = 1
    normalpha(:,t) = normalpha(:,t)./scaling(t);    
end

% 3 Termination
%logalpha(:,t) = log(alpha(:,t));
logpseq = sum(log(scaling));

%% backward algorithm
% for dwHMMtrain

% 1 Initialization
normbeta = ones(numState,length(seq));

% 2 Induction
% traverse time backwards!
for t = length(seq)-1: -1 : 1
    % beta_t(i) = sum over j (A(i,j) B(j,seq(t+1))*beta(j,seq(t+1)))
    % scaled version:
    for state = 1:numState
        normbeta(state,t) = sum(A(state,:)' .* B(:,seq(t+1)) .* normbeta(:,t+1),1) ./ scaling(t+1);
    end
end

